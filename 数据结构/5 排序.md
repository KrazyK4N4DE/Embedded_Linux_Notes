# 排序算法

**排序的稳定性**：大小相同的两个元素在排序之前和排序之后的先后顺序不变，则这个排序算法就是稳定的。如数组[5, 3, 3]，排序过后这两个 `3` 的先后顺序没变，就是稳定的。

## 基础排序算法

三种基础排序算法比较：

|排序算法|最好情况|最坏情况|空间|稳定性|
|--------|-------|-------|----|-----|
|冒泡排序 (优化)|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|插入排序|$O(n)$|$O(n^2)$|$O(1)$|稳定|
|选择排序|$O(n^2)$|$O(n^2)$|$O(1)$|不稳定|

### 冒泡排序

1. 共进行N轮排序。
2. 每一轮排序从数组的最左边开始，两两元素进行比较，如果左边元素大于右边的元素，那么就交换两个元素的位置，否则不变。
3. 每轮排序都会将剩余元素中最大的一个推到最右边，下次排序就不再考虑这些已经在对应位置的元素。

可以进行优化：

- 实际上排序并不需要N轮，而是N-1轮即可，因为最后一轮只有一个元素未排序了，相当于已经排序了，所以说不需要再考虑了。
- 如果整轮排序中都没有出现任何的交换，那么说明数组已经是有序的了，不存在前一个比后一个大的情况。

```C++
void BubbleSort(int* arr, int size)
{
    for (int i = 0; i < size - 1; i++)  // 优化1：排序只需要size - 1轮，因为最后一轮只有一个元素未排序，且不用排了
    {
        bool flag = 1;  // 优化2：标记位，当在这一轮排序中都没出现任何交换，说明数组已经是有序的了
        for (int j = 0; j < (size - 1) - i; j++)
        {
            if (arr[j] > arr[j + 1])
            {
            flag = 0;  // 发生交换时，将flag置0
            int tmp = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = tmp;
            }
        }
        if (flag) break;  // 没变为0说明没交换，数组已是有序的，结束循环，节省一点时间
    }
}
```

### 插入排序

1. 共进行N轮排序。
2. 每轮排序会从后面依次选择一个元素，与前面已经处于有序的元素，从后往前进行比较，直到遇到一个不大于当前元素的的元素，将当前元素插入到此元素的前面。
3. 插入元素后，后续元素则全部后移一位。
4. 当后面的所有元素全部遍历完成，全部插入到对应的位置之后，排序完成。

```C++
void InsertSort(int arr[], int size)
{
    for (int i = 1; i < size; i++)  // int i = 1是假设第一个元素没有有序无序之说
    {
        int tmp = arr[i], j = i;
        for (; j > 0 && arr[j - 1] > tmp; j--)
            arr[j] = arr[j - 1];
        arr[j] = tmp;
    }
}
```

**优化**：使用二分搜索算法来查找对应的插入位置，这样就可以节省查找插入点的时间。

稳定性：没有优化时，稳定；二分搜索优化后，不稳定。

### 选择排序

1. 共进行N轮排序 (最后一轮也可以不排，因为只剩一个元素了)。
2. 每轮排序会从后面的所有元素中寻找一个最小的元素出来，然后与已经排序好的下一个位置进行交换。
3. 进行N轮交换之后，得到有序数组。

```C++
void SelectSort(int arr[], int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        int min = i;  // 记录一下当前最小的元素，默认是剩余元素中的第一个元素
        for (int j = i; j < size; j++)
            if (arr[j] < arr[min]) min = j;
        int tmp = arr[min];
        arr[min] = arr[i];
        arr[i] = tmp;
    }
}
```

**优化**：每次不仅选出最小的，还选出最大的，小的往左边丢，大的往右边丢，这样就能够有双倍的效率完成。

## 进阶排序算法

|排序算法|最好情况|最坏情况|空间|稳定性|
|--------|-------|-------|----|-----|
|快速排序|$O(n\log{n})$|$O(n^2)$|$O(\log{n})$|不稳定|
|希尔排序|$O(n^{1.3})$|$O(n^2)$|$O(1)$|不稳定|
|堆排序|$O(n\log{n})$|$O(n\log{n})$|$O(1)$|不稳定|

### 快速排序(分治思想)

1. 在一开始，排序范围是整个数组。
2. 排序之前，我们选择整个排序范围内的第一个元素作为基准，对排序范围内的元素进行快速排序。
3. 先从最右边向左看，依次将每一个元素与基准元素进行比较，如果发现比基准元素小，那么就与左边遍历位置上的元素（一开始是基准元素的位置）进行交换，此时保留右边当前遍历的位置。
4. 交换后，转为从左往右开始遍历元素，如果发现比基准元素大，那么就与之前保留的右边遍历的位置上的元素进行交换，同样保留左边当前的位置，循环执行上一个步骤。
5. 当左右遍历撞到一起时，本轮快速排序完成，最后在最中间的位置就是基准元素的位置了。
6. 以基准位置为中心，划分左右两边，以同样的方式执行快速排序。

```C++
void QuickSort(int arr[], int start, int end)
{
    if (start >= end) return;
    int left = start, right = end, pivot = arr[left];  // pivot是比较的基准
    while (left < right)
    {
        while (left < right && arr[right] >= pivot) right--;  // 从右向左看，直到遇到比基准小的
        arr[left] = arr[right];  // 遇到比基准小的，就丢到左边去
        while (left < right && arr[left] <= pivot) left++;  // 从左向右看，直到遇到比基准大的
        arr[right] = arr[left];  // 遇到比基准大的，就丢到右边去
    }
    arr[left] = pivot;  // 再把基准值换回来
    // 基准值左右的数组分区快排 (不包含基准)
    QuickSort(arr, start, left - 1);
    QuickSort(arr, left + 1, end);
}
```

### 希尔排序 (缩小增量排序)

是插入排序的进阶改良，插入排序虽然很好理解，但是在极端情况下会出现让所有已排序元素后移的情况 (比如刚好要插入的是一个特别小的元素) 为了解决这种问题，希尔排序对插入排序进行改进，它会对整个数组按照步长进行分组，优先比较距离较远的元素。

1. 首先求出最初的步长，N/2即可。
2. 将整个数组按照步长进行分组，也就是两两一组 (如果N为奇数的话，第一组会有三个元素)。
3. 分别在这些分组内进行插入排序。
4. 排序完成后，将步长/2，重新分组，重复上述步骤，直到步长为1时，插入排序最后一遍结束。

```C++
void ShellSort(int arr[], int size)
{
    int step = size / 2;  // 步长
    while (step >= 1)
    {
        for (int i = step; i < size; i++)  // 原先的插排是i = 1，现在是i = step
        {
            int tmp = arr[i], j = i;
            for (; j >= step && arr[j - step] > tmp; j -= step)
                arr[j] = arr[j - step];
            arr[j] = tmp;
        }
        step /= 2;  // 重新计算步长
    }
}
```

实际上的时间复杂度可能比 $O(n^2)$ 还小，因为能够保证小的元素一定往左边靠，所以排序次数实际上并没有我们想象中的那么多。

### 堆排序

1. 首先将给定的数组调整为一个大顶堆。  
① 从最后一个非叶子结点 (从上往下) 开始调整：若其子结点大于它，则与最大的子结点交换。  
② 从后往前循环步骤①，直至第一个非叶子结点 (根结点) 调整完。  
③ 重新向下堆化调整，知道数符合大顶堆的性质。  
2. 进行N轮选择，每次都选择大顶堆顶端的元素从数组末尾开始向前存放（交换堆顶和堆的最后一个元素）
3. 交换完成后，重新对堆的根结点进行调整，使其继续满足大顶堆的性质，然后重复上述操作。
4. 当N轮结束后，得到的就是从小到大排列的数组了。

```C++
// 交换函数
void Swap(int* a, int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
// 堆化函数
void MakeHeap(int arr[], int start, int end)
{
    while (start * 2 + 1 <= end)     //如果有子树，就一直往下，因为调整之后有可能子树又不满足性质了
    {
        int child = start * 2 + 1;    //因为下标是从0开始，且堆是从下标1开始放元素，所以左孩子下标就是i * 2 + 1，右孩子下标就是i * 2 + 2
        if (child + 1 <= end && arr[child] < arr[child + 1])   //如果存在右孩子且右孩子比左孩子大
            child++;    //那就直接看右孩子
        if (arr[child] > arr[start])   //如果上面选出来的孩子，比父结点大，那么就需要交换，大的换上去，小的换下来
            Swap(&arr[child], &arr[start]);
        start = child;   //继续按照同样的方式前往孩子结点进行调整
    }
}
// 堆排序
void HeapSort(int arr[], int size)
{
    for (int i = size / 2 - 1; i >= 0; i--)   //我们首选需要对所有非叶子结点进行一次堆化操作，需要从最后一个到第一个，这里size/2计算的位置刚好是最后一个非叶子结点
        MakeHeap(arr, i, size - 1);
    for (int i = size - 1; i > 0; i--)    //接着我们需要一个一个把堆顶元素搬到后面，有序排列
    {
        Swap(&arr[i], &arr[0]);    //搬运实际上就是直接跟倒数第i个元素交换，这样，每次都能从堆顶取一个最大的过来
        MakeHeap(arr, 0, i - 1);   //每次搬运完成后，因为堆底元素被换到堆顶了，所以需要再次对根结点重新进行堆化
    }
}
```

## 其它排序算法

|排序算法|最好情况|最坏情况|空间|稳定性|
|--------|-------|-------|----|-----|
|归并排序|$O(n\log{n})$|$O(n\log{n})$|$O(n)$|稳定|
|计数排序|$O(n+k)$|$O(n+k)$|$O(k)$|稳定|
|桶排序|$O(n+k)$|$O(n^2)$|$O(k+n)$|稳定|
|基数排序|$O(n\times k)$|$O(n\times k)$|$O(k+n)$|稳定|

### 归并排序

利用递归分治的思想，将原本的数组进行划分，然后首先对划分出来的小数组进行排序，最后再合并为一个有序的大数组。

![20230107003455](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230107003455.png)

```C++
// 数组合并
void Merge(int arr[], int tmp[], int left, int leftEnd, int right, int rightEnd)
{
    int i = left, size = rightEnd - left + 1;  // 这里需要保存一下当前范围长度，后面使用
    while (left <= leftEnd && right <= rightEnd)  // 如果两边都还有，那么就看哪边小，下一个就存哪一边的
    {
        if (arr[left] <= arr[right])
            tmp[i++] = arr[left++];
        else
            tmp[i++] = arr[right++];
    }
    while(left <= leftEnd)  // 如果右边看完了，只剩左边，直接把左边的存进去
        tmp[i++] = arr[left++];
    while (right <= rightEnd)  // 同上
        tmp[i++] = arr[right++];
    for (int j = 0; j < size; j++, rightEnd--)  // 全部存到暂存空间中之后，暂存空间中的内容都是有序的了，此时挨个搬回原数组中 (注意只能搬运范围内的)
        arr[rightEnd] = tmp[rightEnd];
}
// 归并排序
void MergeSort(int arr[], int tmp[], int start, int end)  // 要进行归并排序需要提供数组和原数组大小的辅助空间
{
    if (start >= end) return;
    int mid = (start + end) / 2;
    // 对左半和右半分别进行归并排序
    MergeSort(arr, tmp, start, mid);
    MergeSort(arr, tmp, mid + 1, end);
    // 上面完事之后，左边和右边都是有序状态了，此时再对整个范围进行一次归并排序即可
    Merge(arr, tmp, start, mid, mid + 1, end);
}
```

### 计数排序、桶排序

要求是数组长度为N，且数组内的元素取值范围是 `0 ~ M-1` 之间 (M小于等于N)。

如下面的数组，元素范围为1~6。先对其进行一次遍历，统计每个元素的出现次数，统计完成之后，把这些值挨个填回去。

![20230107005137](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230107005137.png)

计数排序存在缺点：

- 当数组中最大最小值差距过大时，我们得申请更多的空间来进行计数，所以不适用于计数排序。
- 当数组中元素值**不是整数**的情况下就没办法统计了。

桶排序是计数排序的延伸，同样有元素取值范围的要求和空间缺点。建立桶来统计：

![20230107005426](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230107005426.png)

### 基数排序

基数排序依然是一种依靠统计来进行的排序算法，但是它不会因为范围太大而导致无限制地申请辅助空间。它的思路是，分出10个基数出来(从0 - 9) 我们依然是只需要遍历一次，我们根据每一个元素的个位上的数字，进行分类，因为现在有10个基数，也就是10个桶。个位完事之后再看十位、百位......
