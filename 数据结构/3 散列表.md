# 散列表

散列又称哈希 (Hash)，属于查找方面的内容。**理想情况下查找的时间复杂度可达到常数阶**。

## 散列查找

通过**哈希函数**将要参与检索的数据与**哈希值**关联起来，生成一种便于搜索的数据结构，我们称其为**散列表** (哈希表)。

也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了。

### 哈希函数

哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果。

**应用**：**校验文件完整性**。下载或传输来的文件，使用哈希函数去计算其哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。常见的哈希函数有SHA-1、MD5。

### 哈希表

可以将哈希函数计算出来的元素放入哈希表中，保存的位置则与对应的哈希值有关。例如比较简单的哈希函数就是取模操作，哈希表长度是多少 (长度最好是一个素数)，模就是多少：  
![20230102152237](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102152237.png)  
若要插入新元素17，则：  
![20230102152330](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102152330.png)  
算出来的哈希值为8，所以元素就放在下标为8的位置。

查找指定数据时，只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。

## 哈希冲突

某些情况下，哈希值会出现相同的情况：  
![20230102152738](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102152738.png)

哈希冲突是不可避免的，只能通过使用更加高级的哈希函数来尽可能避免这种情况。

### 线性探测法

发现冲突时，找哈希表中相邻的位置上有没有为空的，只要哈希表没装满，那么肯定是可以找到位置装下这个元素的，这种类型的解决方案统称为线性探测法。

$h_i(key)=(h(key)+d_i)\%TableSize$

$d_i$ 是随着哈希冲突次数增加而增加的量，默认为0。  
![20230102154322](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102154322.png)  
出现哈希冲突时，$d_i$ 自增，继续寻找下一个空位：  
![20230102154412](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102154412.png)  
找到空位后就插入元素。

**不足**：有些元素可能是通过线性探测补到其他位置上的，如果删除元素，那么很有可能会影响到前面的查找操作。

### 二次探测再散列法

左右开弓探测，以免后面没空位，得转一圈回来才能找到对应的位置，浪费时间。

查找增量序列为：$1^2, -1^2, 2^2, -2^2, ..., q^2, -q^2$，其中 $q\leq[TableSize\div 2]$。比如现在要插入元素33，发现已经有冲突了：

![20230102155905](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102155905.png)

### 链地址法

当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：  
![20230102160124](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20230102160124.png)

通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，当链表变得很长时，**查找效率也会变低**，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。
