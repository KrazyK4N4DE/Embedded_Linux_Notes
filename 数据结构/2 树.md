# 树形结构

一个结点下面可能会连接多个结点，并不断延伸，每个结点都有可能是一个分支点，延伸出多个分支。  
*分支只能向后单独延申，**不能与其它结点相交**。*  

![20221224220045](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221224220045.png)  

## 术语 (以上图为例)

* 根结点 (root)：位于最上方的结点。
* 度 (degree)：分支的数目。所有结点度的最大值称作数的度。
* 子树 (subtree)：结点延伸下去的一切。如B以及其后的一切，就是一棵A的子树。
* 层次 (level)：从上往下，根结点的为1，依次+1.所有结点最大的层次，称作树的深度 (depth)。
* 叶子结点：没有任何子结点 (度为0) 的结点。
* 兄弟结点：父结点是同一个。如B和C就是兄弟结点。
* 祖先结点：从某结点往上知道根结点 (包括) 的路径上所有结点。如L的祖先结点为A、B、E。
* 森林：多棵树的集合。

## 二叉树 (Binary Tree)

特殊的树，**度最大为2**，且任何结点的子树有左右之分，不能颠倒顺序。

* 5种基本形态

![20221225132442](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225132442.png)  

* 满二叉树  
左右子树都有，且叶子结点都在同一层，没出现任何度为1的结点。

* 完全二叉树  
只有最后一层有空缺，且所有叶子结点是从左往右排列的。  
*一棵满二叉树，一定是一棵完全二叉树。*

### 树与森林的转换

#### 树 → 二叉树

* 准则

> 最左的子结点 → 左子树子结点  
> 兄弟结点 → 右子树子结点  

![20221225134733](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225134733.png)  
*树转化为二叉树后，**根结点一定没有右子树**。*

#### 二叉树 → 树

* 反推

> 左子树子结点 → 最左的子结点  
> 右子树子结点 → 兄弟结点  

#### 森林 → 二叉树

先将森林中所有树转换为二叉树，再依次连接 (准则一样，**根结点之间视为兄弟结点**)。  
*森林转换为二叉树后，根结点就存在右子树了。*

### 二叉树的性质

#### 性质1

**第 `i` 层的最大节点数**为 $2^{i-1}$ 个。

#### 性质2

深度为 `k` 的二叉树，可具有的**最多结点数**为：

$\displaystyle n=\frac{a_1\times (1-q^k)}{1-q}=\frac{1\times (1-2^k)}{1-2}=2^k-1$

顺便得出，**树的边数**为 $E=n-1$

*Tip:对于 `m`叉树，性质1、2也成立，只需把底数换成m即可。*

#### 性质3

设度为0、1、2的结点数量分别为 $n_0、n_1、n_2$，由于二又树中只有这三种类型的结点，则**结点总数**：

$n=n_0+n_1+n_2$

边数之和 $E=n_1+2n_2$

结合性质2的 $E=n-1$，可得**结点总数**新求法：
$n=n_1+2n_2+1$  
即 $n_0+n_1+n_2=n_1+2n_2+1$，化简得：$n_0=n_2+1$  
可用于求**叶子结点数**。

#### 性质4

完全二叉树的最后一层可满可不满，则一棵完全二叉树的**总结点数**满足：

$2^{k-1}≤n≤2^k-1$

只看左边，取对数得：$k-1≤\log_{2}{n}$  
故一棵具有 `n` 个结点的完全二又树**深度**为：

$k=\log_{2}{n}+1$

#### 性质5

对于任意一结点 `i`，结点序号为从上向下、从左向右：

* 对于**有左右子的结点**，左子为 `2i`，右子为 `2i+1`。
* 若 i=1，则此结点为**根结点**，若 i>1，则其父结点为 $\displaystyle\frac{i}{2}$。
* 若 2i>n，则结点没有左子，若 2i+1>n，则没有右子。

***Q：n个结点可以构造出多少种不同的二叉树？***
> 结果数列为**卡特兰数**，通项公式为：
>  
> $\displaystyle C_n=\frac{1}{n+1}C_{2n}^n=\frac{1}{n+1}\times\frac{(2n)!}{n!\times(2n-n)!}=\frac{(2n)!}{n!\times(n+1)!}$

### 二叉树的构建

* 顺序存储结构：数组表示，结点根据性质5的编号位置存放，不方便，且存在大量计算。
* 链式存储结构：节点需要指向左右子树的指针各一个。

### 二叉树的遍历

以图为例：  
![20221225144410](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225144410.png)  

#### 前序遍历

* 步骤：

> Step1：打印根结点  
> Step2：遍历左子树  
> Step3：遍历右子树

如果不用递归实现，则需要栈来手动实现。

**结果**：ABDECF

*规律：根结点必在最前，父结点在子结点之前。*

#### 中序遍历

* 步骤：

> Step1：遍历左子树  
> Step2：打印根结点  
> Step3：遍历右子树

相比前序遍历，就是打印时机有变化。

**结果**：DBEACF

*规律：对任意结点，其左子树都打印在左边，右子树打印在右边。*

#### 后序遍历

* 步骤：

> Step1：遍历左子树  
> Step2：遍历右子树  
> Step3：打印根结点

**结果**：DEBFCA

*规律：根结点必在最后，父结点在子结点之后。*

#### 层序遍历

需要用**队列**实现。

* 步骤：

> Step1：根结点存入队列  
> Step2：循环以下两步
>  
> * 出队，得到一个结点，并打印其值。
> * 将此结点的左右子结点入队。

**结果**：ABCDEF

*规律：一层一层地打印结点。*

## 高级树结构

### 线索化二叉树

一棵二叉树的某些结点的子树为NULL，可以用这些空指针，按指定的遍历顺序指向下一结点。

**作用**：再次遍历时会很方便。

* 规则  
结点的左指针：指向当前遍历顺序的前驱结点。  
结点的右指针：指向当前遍历顺序的后继结点。

### 二叉查找树

*利用二叉查找树搜值，效率有很大提升。*

* 左于树中所有结点的值，均小于父结点的值。
* 右子树中所有结点的值，均大于父结点的值。
* 二又查找树的子树也是二叉查找树。

#### 删除操作

* 要删除结点的情况：  
① 叶子结点 (度为0)  
② 只有一个子结点 (度为1)  
③ 有两个子结点 (度为2)

* 情况①：直接删。

* 情况②：删了后连子结点。

* 情况③：  
选 其**左子树中最大结点**或**右子树中最小结点** 上位。  
*最大结点、最小结点的度必定是 0 或 1。*  
Step1：找到最大 (小) 点  
Step2：用其值替换要删的结点  
Step3：删掉最大 (小) 点 (情况1或情况2)

### 平衡二叉树 (AVL树)

二叉查找树在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡现象，严重影响查找效率。

**性质**：

* 属于二叉查找树。
* 任意结点的左右子树也是二叉查找树，
* 从根结点开始，左右子树高度差必须 ≤1 才平衡。

平衡因子：结点的 **左子树高度 - 右子树高度**

几种失衡情况：
![20221225154554](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225154554.png)  

**失衡解决方案**：先找最小不平衡子树，即从不平衡的值最小的结点开始，向左子树找两个更小的点。

* LL型：右旋 (左子结点为中心，右边顺时针摆)
* RR型：左旋 (右子结点为中心，左边逆时针摆)
* LR型：先下面两点左旋，再三点右旋
* RL型：先下面两点右旋，再三点左旋

**平衡二叉树的不足**：严格要求高度差不能超过1，这样每插入一个结点，就有很大概率导致失衡，旋转操作过多。

### 红黑树

一种平衡二叉查找树。

**作用**：通过不严格平衡和改变颜色，能在一定程度上减少旋转次数，提升整体性能。

* 规则：  
① 每个结点为黑\红色  
② **根结点必为黑色**  
③ 不能有两个连续的红色  
④ 所有空结点为黑色 (红黑树将空结点视为叶子结点)  
⑤ 每个结点到空结点 (NIL) 路上的黑结点个数都相等  
*Tip：新插入的结点，默认为红色。*

* 插入新结点的准则：  
① 插入空树，即作为根结点，则为黑色  
② 若父结点为黑色，直接插入就行  
③ 若父结点及其兄弟结点皆为红，则将它们变黑，再将爷结点变红 (变色后继续往上看有没有破坏之前结点的规则)  
④ 若父结点为红，其兄弟结点为黑，则先根据失衡情况旋转，再将新旧父结点互换色  

***Q：红黑树与B树的关系？***
> 红黑树与4阶B树有等价性。

## 其它树结构

### B树 (Balance Tree)

为**磁盘数据读取**而设计，高度平衡且有序。

**作用**：硬盘IO次数比内存慢，而B树就适合在硬盘上保存数据，减少IO次数，提高查找效率。  
设度数为 `m`，则 m≥2。

**规则**：

* 左边结点一定比右边的小。
* 每个结点**最多 m 个**孩子。
* 除了根结点和叶子结点，其它结点**至少 $[\frac{m}{2}]$ 个**孩子。
* 若根结点不是叶子结点，则**至少 2 个**孩子。
* 所有叶子结点都在同一层。
* 一个结点的**键值数**满足：$[\frac{m}{2}]-1≤n≤m-1$。

#### 插入操作

* 结点键值数未满,则将新元素插入到结点,并保持元素大小顺序。
* 结点元素已满，则分裂为两个结点：  
Step1：从该结点**所有元素和新元素中**先出一个**中位数**作为分割值 (偶数个数的话，选偏右的)  
Step2：小于中位数的放到左子树，大于的放右子树  
Step3：中位数上升到父结点中，没有父结点就创一个

#### 删除操作

* 删叶子结点元素：  
① 正常情况直接删  
② 删后键值数少于最小值，则找兄弟 (只能左右相邻) 借  
③没得借就跟兄弟结点以及对应分割值**合并到同一层**

* 删某个父结点元素：  
① 一般删的都是分割值，需从左右子树中找一个新分割值 (左子树最大or右子树最小) 上来  
② 拿上来后键值数少于最小值，则只能合并了

### B+树

比B树更高的查询性能，很多数据库都用B+树作为底层数据结构。

**规则**：

* 父结点有 `k` 个子树，就有 `k` 个键值，键值不保存数据，只作为索引，卫星数据 (要保存的内容) 都保存在叶子结点中。
* 最后一层形成一个有序链表，叶子结点按从小到大的顺序排列。
* 父结点的元素一定会在子结点中存在，且在子结点元素中最大 (或最小) 元素。

![20221225165442](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225165442.png)  

### 哈夫曼树 (Huffman Tree)

给定 `N` 个权值作为 `N` 个叶子结点，构造一棵二叉树，若该树的**带权路径长度最小**，称为哈夫曼树。

#### 带权路径长度

所有 叶结点权值 × 其到根结点经过的边数 (一般是叶结点层数)，即：

$\displaystyle WPL=\sum_{i=1}^{n} (vallue(i)\times depth(i))$

![huffman](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/huffman.png)  
如上图所示

* 左图：$WPL=5\times 2+7\times 2+2\times 2+13\times 2=54$
* 右图：$WPL=5\times 3+2\times 3+7\times 2+13\times 1=48$

右图的带权路径长度更小 (其实也是排列最小的)。

#### 哈夫曼树的应用

**数据 (文件) 压缩**：如压缩字符串ABCABCD，可使用哈夫曼编码压缩保存到硬盘。

构建哈夫曼树后，对分支标注，左0右1，如图所示：  
![20221225172841](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221225172841.png)  
则：A → 110，B → 0，C → 111，D → 10

* 压缩操作：将字符串翻译成对应哈夫曼编码，ABCABCD = 110 0 111 110 0 111 10
* 解压缩操作：反过来写，110 0 111 110 0 111 10 = ABCABCD

#### 构建哈夫曼树 (需要优先级队列)

***只要保证越大的权值越靠近根结点，那么出来的一定是哈夫曼树。***

* 步骤：

> Step1：每个结点都单独视为树，放到森林里  
> Step2：选两棵权值最小的树，作为一棵新树的左右子树，得到的树根结点权值为这两个结点之和，放到森林里  
> Step3：重复步骤2，直到森林里只剩一棵树为止，这棵树就是哈夫曼树

* 优先级队列  
与普通队列不同，它允许入队时插队 (权值越大或越小的元素优先排到前面去)，当然出队还是一律从队首出来。

### 堆 (Heap)

堆必须是一棵**完全二叉树**，不同于二叉查找树的左小右大，堆中子结点一定比父结点大或小。故根结点值最小的称为小根堆 (小顶堆)，根结点最大的称为大根堆 (大顶堆)。

*堆一般是以**数组**形式存储，可用于实现优先级队列。*  
![20221226203843](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226203843.png)  
如上图为大根堆，堆的插入和删除操作都要遵循完全二叉树和大(小)根堆的性质。

#### 插入 (入队) 操作

![20221226204227](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226204227.png)
遵循完全二叉树的性质，按顺序在最后插入新结点。同时要满足大根堆的性质，故需要调整 (堆化)，调整方法：**与其父结点交换**。

![20221226205333](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226205333.png)  
![20221226205407](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226205407.png)  
还没完，需要继续向上比较，直到稳定为止，此时7依然是小于8的，所以说需要继续交换：

![20221226205614](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226205614.png)  
8号结点目前的下标 i=3，则其父结点下标为 (i/2)=1。  
满足大根堆的性质，堆化结束，最大的元素排到了最前面，故也能看成是优先级队列。

#### 删除 (出队) 操作

![20221226210742](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226210742.png)  
删除队首元素。要保证删除之后依然是一棵完全二叉树，所以说我们**先把排在最后面的拿上来顶替一下**：

![20221226210916](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226210916.png)  
接着需要按照与插入相反的方向，**从上往下进行堆化操作**，规则是一样的，遇到大的就交换，直到不是为止：

![20221226211203](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/20221226211203.png)  
依然是最大的元素排在队首，且整棵树依然是一颗完全二叉树。

*Tip：堆在排序上也有着非常方便的地方。*
