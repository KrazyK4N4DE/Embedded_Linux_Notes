# 第8章 函数进阶

## 内联函数

**特点**：节省函数调用时间，运行速度比常规函数稍快。但代价是需要占用更多内存空间，因为编译后若有n个地方调用函数，程序就会有n份函数拷贝。

* 什么时候用？  
代码很短，执行函数代码时间比函数调用机制时间短时用。**头文件内函数定头为须是内联！**

* 怎么用？  
在函数的定义和声明前加上关键字 `inline`。通常是只写定义，并放在声明的位置。

* *Tips：*  
① c++内联远胜于c的宏定义  
② 内联函数不能递归  
③ 当函数过大，编译器可能不会满足内联请求

## 引用变量

**用途**：把形参变成实参的别名。

* 何时用？  
① 能够修改函数中的数据对象  
② 提高效率、运行速度。如引用结构、类对象

*Tip：返回值为引用的函数，切勿返回**块内自动变量和临时变量的引用**！！！*

### 创建引用变量

符号 `&`，如：

```C++
int rats;
int& rodents = rats;
```

像指针一样，`int&` 即指向 `int` 的引用。
声明后，rats和rodents指向相同的值和内存单元。  

* *引用与指针的区别*：  
① 必须在声明引用时就初始化  
② 一旦与某个变量关联，就一直效忠于它

### const引用

如果实参与引用参数不匹配，仅当引用参数为const引用时，C++才允许生成临时变量。

* 具体何时生成：  
① 实参类型正确，但不是左值  
② 实参类型不对，但可转换为正确的类型

*故const引用使函数能够正确生成并使用临时变量。*

### 右值引用 (C++)

**目的**：是能提供一些操作的有效实现。  
使用 `&&` 声明，详见18章 “移动语义”。

### 值、引用、指针的传参

* 数据对象很小 (内置数据类型或小型结构)，且不需修改，则**按值传递**。
* 数据对象是数组，则只能**按指针传递**。
* 数据对象是较大结构，则**按引用或指针传递**。
* 数据对象是类对象，则**按引用传递**。

## 默认参数

函数调用中省略实参，则会自动使用一个值。

* 怎么用？  
在函数原型中给形参赋值即可。

*Tip：要为某个形参设默认值，则必须为它**右边的所有参数**提供默认值。*

## 函数重载 (函数多态)

**用途**：不同类型参数传进来，也可实现相同工作。  
C++允许定义名称相同的函数，只需它们的**特征标** (参数列表) 不同。  
*Tip：类型引用和类型本身视为同一特征标。*

## 函数模板 (通用编程)

如交换模板：

```C++
template <typename AnyType>
void Swap(AnyType& a, AnyType& b)
{
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
```

* 关键宇 `template` 和 `typename` 是必需的；其中 `typename` 是C++98的，在这之前为 `class` 。
* `AnyType` 为可自定义的命名，意为通用类型名，一般程序员用 `T` 表示。
* 前两段为**模板函数原型**。
* **模板并非函数定义**，只是提供生成定义的方案。
* 使用函数时，编译器生成该函数对应类型的版本，所以**函数模板不能缩短可执行程序**。
* 并非所有模板参数都必须是 `AnyType` 类型。

### 函数模板的不足

很可能无法处理一些类型，如**结构和数组的一些运算**。

* 解决方案：  
① 重载运算符  
② 为特定类型提供**具体化**模板定义

### 显式具体化

**作用**：处理特定类型。  
**用法**：函数原型和定义应从 `template <>` 大头，在函数名后再添加一个 `<>`，并在里面写上指定的类型。  
如有一结构体名为 `job`，为处理该类型，使用显式具体化 (**具体化后仍是模板**)：

```C++
template <> void Swap<job>(job&, job&);
```

*对于同一函数名，各种函数的优先级：*  
> **非模板 > 显式具体化 > 常规模板**  

* 让程序主动调用模板  
**函数调用**时，在函数名后加 `<>`，告诉编译器应选择模板函数，而不是非模板。

### 实例化

**作用**：为模板先生成**函数定义**，在写库函数有用。  
**用法** (显式)：以int为例，

```C++
template void Swap<int>(int, int);
```

即**显式具体化**的代码去掉第一个 `<>`。

## 新的起别名方式 (C++11)

```C++
using xx = xxx;
```

作用同 `typedef`，但是 `using` 能用于模板具体化。

## 不确定的数据类型 (C++11)

对于函数模板，如

```C++
template <class T1, class T2>
void func(T1 x, T2 y)
{
    ......
}
```

无法确定 x+y 的类型，可用 `decltype` 或 `auto` 解决。

### decltype

```C++
decltype(expression) var;
```

表示 `var` 的类型声明为 `expression` 的类型。

* var与expression类型相同，**包括const**。
* 若expression是函数调用，则var类型与函数返回类型相同 (**并不会实际调用函数**)。
* expression在用括号括起来，则var为该类型的**引用**。

### 后置返回类型

针对函数返回类型不确定的情况。  
**用法**：

```C++
auto func(T1 x, T2 y) -> decltype(x + y)
{
    ......
}
```

这里 `auto` 是占位符。

***Q：既然已有auto，为何还需要decltype？***
> 有时需要从表达式类型推断出要定义的变量类型 (auto做得到)，  
> 但不想用该表达式的值初始化变量 (auto做不到)。

* `auto` 的使用规则：  
① 用auto声明必须要初始化  
② auto不能用于函数的**形参**和**返回值类型**  
③ `auto` 和 `auto*` 没有区别,但声明引用时须加 `&`  
④ 在同一行声明多个变量时，类型要相同  
⑤ 不能用来声明**数组**
