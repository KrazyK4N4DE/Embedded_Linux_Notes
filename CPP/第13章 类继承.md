# 第13章 类继承

## 类继承

- 继承了基类的数据成员。
- 继承了基类的方法。

> ```C++
> class Derive:Base {..};
> ```

*默认 `private` 继承，可加关键字修改。*

***Q：什么不能被继承？***

- 构造函数
- 析构函数
- 赋值运算符

### 派生类的构造函数

用到基类的构造函数，需使用**成员初始化列表**将基类参数传给基类构造函数。

***Q：为什么派生类构造函数用到基类构造函数？***  
派生类必须使用基类的**公有**方法访问基类的私有成员。

### 析构函数

创建派生对象时，程序首先调用基类构造函数，再调用派生类构造函数。  
故释放对象时，析构函数的调用顺序相反。

### 派生类与基类的引用关系

对于类的指针或引用，基类指针/引用可以指向/引用派生类对象，但是派生类不行。  
*爸爸可以引用儿子，儿子不能引用爸爸。因为儿子没有爸爸见识广。*

---

## 多态公有继承 (is-a关系)

同一方法在派生类和基类中的行为是不同的。

实现多态的方式：

- 派生类中重新定义基类的方法。
- 使用虚函数。

### 虚函数

关键字 `virtual`，修饰成员函数原型。

- 设方法是通过指针或引用调用的，若使用关键字，将根据**引用或指针指向的对象类型**来选择方法；反之，会根据**指针或引用类型**选择方法。
- 如派生类要实现多态，基类方法应声明为虚的。
- 基类声明**虚析构函数**应成习惯，因为使用虚析构函数可以确保正确的析构函数**序列**被调用。如果不是虚的，则将只调用**指针或引用类型**的析构函数。

#### 联编 (binding)

编译器的工作。对于函数调用应该解释为哪个特定的函数代码块，C++的函数重载和虚函数使得该工作变得困难。

- 静态联编：在编译过程中进行联编，能解决函数重载的解释。
- 动态联编：生成能够在程序运行时选择正确的虚方法代码。

C++默认的选择是静态联编，因为相比于动态联编效率更高。所以若类不会用作基类、派生类不重新定义基类的任何方法，则不需要动态联编。

#### 虚函数工作原理

每个对象都有个隐藏的、指向虚函数地址数组的指针，该数组称为虚函数表。

![虚函数工作原理](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/虚函数工作原理.jpg)

故使用虚函数，会增大内存和执行速度：

- 每个类都会创建(复制)虚函数表。
- 每个对象都将增大，增大量为指向虚函数表指针的大小 (当类继承了多个类时，可能有多个虚函数指针)。
- 每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

Tips：

- 构造函数不能是虚函数。
- 友元不能是虚函数，因为友元不是类成员。
- 若为了实现多态，应确保与原来的原型完全相同。但如果返回类型是基类引用或指针，则可以修改为返回指定派生类的引用或指针，这种特性称为**返回类型协变**。
- 如果基类声明被重载了，则应在派生类中重新定义所有的积累版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。

---

## 关键字protected

- 对于**类外**，protected成员同private成员：只能用public成员访问。
- 对于**派生类**，同public成员，派生类成员可以直接访问基类的protected成员。

---

## 抽象基类 (Abstract Base Class, ABC)

两个类存在共同点，有时用is-a规则的派生并不是一种高效的方法。如椭圆和圆，圆是一种椭圆，但是椭圆的短半轴、长半轴、方向角以及旋转操作对圆来说没什么意义，所以不建议使用is-a派生。

解决办法：将抽象出的共性放到一个ABC中，再从该ABC派生出Circle类和Ellipse类。

### 纯虚函数

抽象基类中有的方法是不确定的，得留到派生出来的类自己定义。因此C++引入纯虚函数，**提供未实现的函数**。

- 真正的ABC必须至少包含一个纯虚函数，包含后ABC就不能创建该类的对象。
- 纯虚函数原型的结尾处为 `= 0`，如：`virtual void Withdraw(double amt) = 0;`。

#### 纯虚函数与虚函数的区别

- 虚函数是为了实现多态，纯虚函数是为了实现接口和抽象基类。
- 有虚函数的类可以实例化，而有纯虚函数的类不可以实例化。
- 纯虚函数首先是虚函数。

---

## 继承与new

假设基类使用了动态内存，则在构造函数、复制构造函数、重载赋值运算符中使用了 `new`，在析构函数中使用了 `delete`。

### 情况1：派生类不使用动态内存分配

不需要析构函数、拷贝构造函数、赋值运算符重载。

### 情况2：派生类使用动态内存分配

必须为派生类定义拷贝构造函数、赋值运算符重载、析构函数。
