# 第12章 类和动态内存分配

## 复制构造函数

用于初始化阶段，将一个对象复制到新对象中。

何时会调用？

- 将新对象初始化为一个同类对象。
- 按值传递对象给函数。
- 函数按值返回对象。
- 生成临时对象。

原型：`Cname(const Cname&);`

### 默认复制构造函数

复制方法为**浅拷贝**，即逐个复制非静态成员。

**不足**：有些成员是用 `new` 初始化的指针，对于浅拷贝，只是复制了地址。两指针指向同一片地址，调用析构函数会出现同一内存释放两次的情况。

### 深拷贝

对于指针，不复制地址，复制指向的数据。
需定义一个复制构造函数，以string类为例：

> ```C++
> string::string(const string& s)
> {
>   len = s.len;
>   str = new char[len+1]:
>   std::strcpy(str,s.str);
> }
> ```

---

## 赋值运算符

将已有对象赋给另一对象时，会调用赋值运算符。
根据实现不同。初始化时用到 `=` 也可能调用赋值运算符。
*故一般**复制构造函数**和**赋值运算符**成对定义。*

原型：

> ```C++
> Cname& Cname::operator=(const Cname&);
> ```

默认赋值运算符的**不足**：同默认复制构造函数的不足。

### 重载(深拷贝)

1. 调用对象可能引用了以前分配的数据，delete掉。
2. **避免将对象赋给自己**，否则再delete就把自己删了。
3. 函数返回一个指向调用对象的引用(*this)。

以string类为例：

> ```C++
> string& string::operator=(const string& s)
> {
>   if(&s == this)
>       return *this;
>   delete[] str;
>   len = s.len;
>   str = new char[len + 1];
>   std::strcpy(str, s.str);
>   return *this;
> }
> ```

*构造函数中使用 `new`：*

- 应有析构函数使用 `delete`。
- 若有多个构造函数，须以相同方式使用 `new`。
- 应定义复制构造函数和赋值运算符，使用深拷贝。

---

## 用new创建对象指针

> ```C++
> Cname* pclass = new Cname(value);
> ```

- 将：
  1. 开辟空间;
  2. 调用对应value的类型的构造函数。
- 仅当显式使用 `delete` 时其析构函数才被调用。

### 定位new运算符

即使用于对象指针，也无法使用 `delete`，那该如何用析构函数来显示提示信息？
**显式调用，跟使用类方法一样：`p->~Cname();`**
注意多个对象的调用顺序，先进后出。

---

## 成员初始化列表

> ```C++
> Cname* Cname(int x) : mem1(x), mem2(0), ......;
> ```

- 只能用于构造函数。
- **非静态const成员**必须用这种格式初始化 (C++11之前)。
- **引用数据成员**必须用这种格式初始化。
