# 第10章 类和对象

***Q：类与结构的区别？***
> ① 都是用成员运算符使用成员。  
> ② 类可以直接放方法，结构体需借助函数指针。  
> ③ 类内成员默认权限private，结构则为public。

## 面向对象三大特性

- 封装 (本章)
- 继承 (13章)
- 多态 (13章)

---

## 封装

将**数据** (成员) 和**操作数据的方法** (成员函数or公有接口) 抽象整合在一起，并加以权限控制。

**目的**：将对象的使用者和设计者分开，对外提供接口，对内提供数据。

**访问控制关键字**：  
![e3c3fb64e91d9063ff66ea5ba5969aa](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/e3c3fb64e91d9063ff66ea5ba5969aa.jpg)  

- protected和private的区别体现在继承上。
- 私有成员只能通过公有成员函数或友元函数访问。

---

## 定义成员函数

- **类内**：自动成为内联函数，也可在类外使用 `inline`。
- **类外**：使用 `::` 并在其前标识所属的类。

---

## 构造函数

**作用**：创建新对象时，**自动**对其初始化。

- 特点：  
① 名称与类名相同  
② 没有声明类型  
③ 形参名不能与类成员名相同，除非使用 `this->xx = xx;`

***Q：对象初始化和赋值的区别？***
> 在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象，效率比初始化低。

### 默认构造函数

为类定义构造函数后就必须为其提供默认构造函数，因为编译器只在没有任何构造函数时提供。

- 提供方式：  
① 给已有构造函数所有参数提供默认值  
② 重载一个没有参数的构造函数  
*Tip：①和②不要同时用，因为只能有一个默认构造函数。*

---

## 析构函数

**作用**：对象过期时，自动调用的函数。可完成清理工作，如构造函数有 `new` 时则析构函数应使用 `delete`。

- 特点：  
① 名称为**类名前加 `~`**  
② 没有声明类型  
③ 不接受参数

### 默认析构函数

未定义析构函数时，编译器将隐式声明一个默认的。

***Q：多个对象过期时，析构函数的调用顺序？***
> 若类对象不是由new创建的，则为自动变量；由于栈的先进后出FILO，后创建的对象，过期后会先调用析构函数。

---

## 成员函数const

**目的**：当方法没有参数时，它使用的对象是由方法调用隐式提供的 (即 `this` )。为保证其不被修改，需要一种新的语法。

**解决方法**：将 `const` 放在函数括号后面，如：

```C++
void show() const;
```

*Tip：**函数定义**和**函数声明**都要加。*

---

## this指针

**目的**：方法有时需要使用或返回**正在调用它的对象**，这个对象被作为隐藏参数传递给方法。`this` 指针用于指向上述对象。

- 用法：
  - `this`：表示对象的地址
  - `*this`：表示对象

*Tip：复制构造函数和赋值重载函数有 `this` 的固定用法。*

---

## 整个类中都恒定的常量

背景：类只是描述了对象的形式，并没有实例化。因此在没创建对象前，没有存值的空间。

### 类中声明一枚举

```C++
enum {Months = 12};
```

#### 枚举类 (C++11)

两个枚举定义中的枚举量可能发生冲突。C++11提供了一种新枚举，其枚举量的作用域为枚举类。

- 创建：

> 使用 `class` 或 `struct`：
>
> ```C++
> enum class egg {Small, Medium, Large};
> enum struct t_shirt {Small, Medium, Large};
> ```

- 使用枚举量：

> 使用枚举名来限定枚举量：
>  
> ```C++
> egg choice = egg::Large;
> t_shirt floyd = t_shirt::Large;
> ```

- *Tips*：

> - 枚举类不能隐式转换为整型。
> - 传统枚举的底层整型由环境决定，而枚举类的底层为int型，可用C++11语法手动指定：
>
> ```C++
> enum class : xxx pizza {Small, Medium, Large};
> ```
>
> `xxx` 必须为整型。
>
> - 上述语法也可以指定常规枚举的底层，没有指定就由环境决定。

### static const

**必须在类内初始化** (C++11允许声明为浮点数)：

```C++
static const int Months = 12;
```

*该常量和其它静态变量存在一起，而非存在对象。*

---

## 静态类成员

### static

**不能在类内初始化**：

```C++
static int num;
```

*所有对象都共享该变量，该变量不属于任何一个对象。*

在类外初始化时，不使用static，需标识类名：

```C++
int className::num = 0;
```

### const

- 同static**不能在类内初始化**，只能在构造函数的初始化列表中进行。
- 对于对象是常量，对于整个类是可变的。

***Q：static，const，static const的区别？***
> static const为常量，static为静态变量，const只能算半个常量。

### 类内成员初始化 (C++)

C++11允许**除static外**其它成员直接初始化。

---

## 抽象数据类型 (ADT)

也称不限定数据类型，以通用的方式描述数据类型。而没有引入语言或实现细节。  
**类、模板**非常适合描述ADT，数据结构的实现也是基于ADT。

---
