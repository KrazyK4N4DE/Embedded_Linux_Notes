# 第11章 类的进阶

## 运算符重载(一种形式的c++多态)

### 格式

> ```C++
> typeName operatorxx(argument-list);
> ```

- xx必须是有效、存在的C++运算符。
- 成员函数接受的参数比非成员版本要少一个，因为其中一个操作数是被隐式传递的调用对象。
- 单目运算符重载相比于双目，少接受一个参数。所以运算符重载作为**成员函数**最多只接受一个参数。

### 重载限制

- 重载中至少有一个操作数是用户定义的类型，以防止为标准类型重载运算符。
- 不能违反运算符原来的句法规则(如单目转双目)。
- 不能创建新运算符。如不能定义operator**()来求幂。
- 不能修改运算符的优先级。
- 一些运算符不能重载，见下图。
  ![ff51008340aff636aa1a3e670e52908](https://image-hosting-1313474851.cos.ap-shanghai.myqcloud.com/Notes/ff51008340aff636aa1a3e670e52908.jpg)
- 这些运算符只能通过成员函数重载：`=`，`()`，`[]`，`->`
  原因：类里提供了默认的这些运算符的重载功能，使用非成员函数会出现二义性。如果成员函数重载，就会覆盖掉类里面的默认重载。

***Tip：***
运算符传统写法(+为例)：`s1.operator+(s2);`
左侧操作对象为**调用对象**，右侧为**参数对象**。故运算符左右不可轻易调换。

### 下标重载

```C++
double &operator[](int n); // 返回double的引用，作左值，用于修改
double operator[](int n) const; // 返回double，作右值，用于读取
```

---

## 友元函数

> 友元类、友元成员函数 见15章

创建友元：原型放在类声明中，并在前加关键字 `friend`。

> ```C++
> friend typeName operatorxx(argument-list);
> ```

- 友元函数不是成员函数。
- 与类的成员函数具有相同的访问权限。
- `friend` 只用在原型前加。

### 常用友元：重载 `<<` ( `>>` 同理)

分析：

- 由于左调用、右参数，所以不能用成员函数。使用友元函数将 `ostream` 对象放第一个。
- 使用运算符时应使用 `ostream` 对象本身，而不是拷贝，故 `ostream` 应按引用传递。

常见写法：

> ```C++
> ostream& operator<<(ostream& os, const Cname& obj);
> ```

***Q：运算符重载，返回值何时需、何时不需加引用？***
加：

- 需要**连续调用操作**的，如上述 `<<`，会用到如 `cout << a << b << endl;`
- 对于二运算符，引用可以**避免默认复制函数的调用**。

不加：

- 对于返回块内局部变量对象的函数，如果加引用，函数执行完后，局部变量被释放，引用将指向一个不存在的对象。

*Tip：如果方法通过计算得到一个新的局部类对象并返回，则可以考虑在return语句中使用**类构造函数**来实现。*

***Q：重载运算符选择，作为成员函数还是非成员函数？***
非成员函数重载时，要访问的成员需放在 `public` ，不太安全。所以**要么成员，要么友元**。

---

## 类的类型转换

### 基本类型 → 类

类中存在只接受**一个参数**的**构造函数**时才能实现。

实现过程：
如类有构造函数 `Cname(double)`，则在将double值赋给对象时，程序将使用构造函数来创建一个临时的类对象，再将临时对象的内容复制到对象中。

**`explicit`**

- 使用：放在构造函数前。
- 作用：关闭这种自动特性，以防止意外的类型转换。
  只能显式转换：`obj = (Cname)19.6;`

### 类 → 基本类型

转换函数原型：

> ```C++
> operator typeName();
> ```

必须是成员函数，无参数，无返回类型。

转换函数定义：尽管没有声明返回，函数也需要return相应的值。

**调用**：
隐式转换：`typeName xx = obj;`
显式转换：`typeName xx = (typeName)obj;`

**二义性问题**：
前提：定义了至少两个不同类型的转换函数。

1. 对于 `cout`，需要显式转换对象，否则会有二义性。
2. 赋值操作，如 `long xx = obj;`，对于能自动转换为 `long` 的类型，其转换函数都是合法的，因此存在二义性，需要显式转换对象。

**转换函数的 `explicit` (C++11)**：同上避免隐式转换。

*Tip：不管是构造函数还是转换函数，都最好使用显式转换，避免隐式转换。*

---
