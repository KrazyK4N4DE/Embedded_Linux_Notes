# 第9章 内存模型和名称空间

## 关于程序和推荐组成

**头文件 + 源文件 x 2**。

* 头文件 (xxx.h)  
① 函数、结构、类、各种模板的声明  
② #define或const定义的符号常量  
③ 内联函数  
*Tip：不要将**函数定义**或**变量声明**放到头文件中，真要放就放**内联**的。*  
*C头文件在C++：去掉 `.h` 并在文件名前加前缀 `c`。*
* 源代码文件1：头文件中声明的函数的定义代码。
* 源代码文件2：main函数。

## 作用域补充

* 类中声明的成员的作用域为整个类。
* 名称空间同理。
* C++提供了作用域解析运算符 `::`，放在变量名前表示使用全局版本。

### 存储说明符

**C++11中**，`auto` 不再是说明符，新增了 `thread_local`。  

* **mutable**  
修饰结构 (类) 的成员。用于指出**即使结构 (类) 变量为const，该成员也可以被修改**。

## 链接性补充

C++中，const全局变量的链接性为内部。

### 语言链接性

链接程序要求**每个不同的函数都有不同的函数名**。

* C链接性：
一个名称只对应一个函数，如C编译器可能将 `spiff` 翻译成 `_spiff`。
* C++链接性：
同一名称可能对应多个函数 (有函数重载)，必须翻译为不同的符号名称，如可能将 `spiff(int)` 翻译为 `_spiff_i`，将 `spiff(double, double)` 翻为 `_spiff_d_d`。

> 可能会出现的问题：要在C++程序中使用C库中预编译的函数，可能会出现符号名称查找不到的情况。  
> 解决办法：在**函数原型**中指出要使用的链接性。如:
>
> ```C++
> extern "C" void spiff(int);   //use C protocol
> extern void spoff(int);   //use C++ protocol (default)
> extern "C++" void spaff(int);   //use C++ protocol
> ```

## 名称空间

使用多个厂商的类库时，可能导致**名称冲突**。为减少该问题，C++提供了名称空间。

* 用法：

```C++
namespace xxx
{
    ......
}
```

***名称空间问题说白了就是作用域问题，一样遵循局部和全局等规则。***

* 访问名称空间的变量：  
作用域解析运算符 `::`，如 `std::cout`。

### using声明

如 `using std::cout;`

* 只导入指定的名称。
* 使用后，变量不需要使用 `::`。
* 与局部名称冲突时，编译器会发出提示。

*Tip：若有两个不同的using声明变量名一样，会导致二义性，**编译器不允许**。*

### using编译

如 `using namespace std;`

* 其内所有的名称都可用。
* 使用后，变量不需要使用 `::`。
* 与局部名称冲突时，局部名称覆盖名称空间版本，且编译器不发出警告。

### 未命名名称空间

其中的变量的潜在作用域：**从声明点到该声明区域末尾**。

### 名称空间使用原则

* using编译和using声明不要滥用，因为它们其实增加了名称冲突的可能性。
* 使用名称空间的变量，取代外部全局变量、静态全局变量。
* 不要在头文件中使用using编译！首先，这掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。
* C++当前提倡将标准函数库放在std中。
* 首选 `::` 运算符或 `using声明` 来导入名称。
* using声明首选设为局部作用域。
