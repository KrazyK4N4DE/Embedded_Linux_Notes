# Linux系统编程

基本概念：

- 程序：源代码或指令，静态的
- 进程：正在执行的程序，动态的
  - 内核为进程分配资源，并在程序结束后回收资源
  - 进程之间是独立的
- 线程：由进程引发，一个进程可有多个线程
  - 优点：占用资源比进程要低，且线程之间共享进程的资源
  - 缺点：某一个线程崩溃了，其它的跟着一起崩
- 任务：程序具体要做的事情

使用`getpid()`和`getppid()`查看当前进程和其父进程的ID。

---

## 创建进程

使用`fork()`：

- **创建一个子进程**并**复制父进程的内容**
- return：创建后，当前进程返回其子进程的pid，子进程返回0；创建失败返回-1
- **孤儿进程**：父进程结束了，而其子进程仍在运行，那么这些子进程就会变成孤儿进程
  - 孤儿进程将被1号进程(systemd或init)所收养，并由init进程对它们完成状态收集的工作。说人话就是会接着运行。
  - 孤儿进程并不会有什么危害。
- **僵死进程**：子进程退出，而父进程没有利用 `wait` 或者 `waitpid` 来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中
  - 僵死进程不占内存。
  - 危害：会占用进程号，而系统所能使用的进程号是有限的，如果有大量僵死进程，则会没有可用的进程号而导致系统**不能产生新的进程**。

### 父进程监控子进程

使用 `wait` 函数：

- 参数：获取子进程退出状态(原因)
- return：返回结束的子进程pid，失败返回-1

---

## 创建线程

使用 `pthread_create`函数：

```C
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```

- thread：指针，线程的ID
- attr：结构体，用于定制各种不同的线程属性
- start_routine：函数指针，新建的线程从此函数开始执行
- arg：指针，start_routine的参数，没有就填NULL

### 进程监控线程

`pthread_join`

---

## 管道

### 匿名管道

只适用于有亲缘关系的进程之间通信。

### 有名管道 (FIFO)

- 没有亲缘关系的进程之间，要使用管道，只能用有名的。
- 有名管道是通过 `mkfifo` 创建一个FIFO文件来实现通信的，收发即是对该文件读写操作。
- 在读该文件时，进程会进入**阻塞状态**，直到其他进程写该文件。

---

## 共享内存

把某块内存空间映射到多个进程。

1. 创建共享内存。
   - 使用 `shmget` 函数：内核层用键值key标识共享内存 (键值是唯一的)，应用层用共享内存标识符。
   - 注意创建共享内存后默认权限为0644，即组用户和其它用户只读。要更改权限，需在第三个参数后或运算。如 `IPC_CREAT | 0666`。
   - 若是两个没有亲缘关系的进程使用共享内存通信，则第一个参数不能是 `IPC_PRIVATE`，因为该参数表示让内核来随机分配，只有亲缘进程中的 `IPC_PRIVATE` 才是一样的。正确做法是两个程序自定一个固定键值来使用。
   - 第二个参数size为申请共享内存的大小，单位为**字节**。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，一般申请的内存大小为页的整数倍。
2. 在不同的进程中将共享内存映射到当前进程空间里。
   - 使用 `shmat` 函数。
3. 解除映射关系。
   - 使用 `shmdt` 函数。
4. 销毁共享内存。
   - 使用 `shmctl` 函数，第二个参数使用 `IPC_RMID`。

---

## 消息队列

通信的数据结构为结构体，因此可以收发任意、多种数据类型。

1. 创建消息队列的结构体。
2. 创建消息队列。
   - 使用 `msgget` 函数，用法和 `shmget` 类似。
   - 若要读写，同样需要改权限。
   - 不同亲缘关系的进程使用消息队列通信，同样使用固定键值代替 `IPC_PRIVATE`。
3. 发送/接收消息队列。
   - 发送：使用 `msgsnd` 函数。
   - 接收：使用 `msgrcv` 函数，第四个参数为0时，接收所有消息队列；若要接收指定消息队列，需要和对应消息队列中的 `mtype` 相同。
4. 销毁消息队列。
   - 使用 `msgctl` 函数，第二个参数使用 `IPC_RMID`。

---

## 信号量 (POSIX)

用于控制任务之间的同步，而不是通信。

### 匿名信号量

1. 初始化信号量。
   - 第二个参数：0表示线程间共享；非0表示进程间共享，则信号量需先放在一块共享的空间中 (`mmap` 或 `shmget` 实现)。
   - 第三个参数：信号量的初始值 (计数器的初始值)。
2. 使用/增加信号量。
   - 使用：使用 `sem_wait` 函数。
   - 增加：使用 `sem_post` 函数。
3. 销毁信号量。
   - 使用 `sem_destroy` 函数，该函数只针对使用 `sem_init` 创建的匿名信号量。

### 命名信号量

- 使用 `sem_open` 创建、打开信号量。
- 使用 `sem_close` 关闭信号量 (并不是销毁，只是解除当前进程和信号量的关联)。
- 使用 `sem_unlink` 销毁信号量。

---

## 互斥锁

主要是用于**线程**，同样控制任务之间的同步。**可以看作是只有上锁和解锁两种状态的信号量**。

---

## 信号

用于进程与内核、进程和进程之间**控制命令**的传输。

- 使用 `signal` 函数捕获信号，然后可进行自定义操作 (注意：对于SIGKILL信号并不能处理，强制退出)。
- 使用 `kill` 函数给指定进程发送指定信号。
